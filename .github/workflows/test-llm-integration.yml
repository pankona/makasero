name: Test LLM Integration

on:
  workflow_dispatch:
    inputs:
      test_prompt:
        description: 'Test prompt for LLM'
        default: 'Hello, AI. Please call the complete function.'
        required: false
      branch:
        description: 'Branch/commit to test (leave empty for current)'
        required: false
        
  issues:
    types: [labeled]
    
  pull_request:
    types: [labeled]
    
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  test-llm:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'issues' && github.event.label.name == 'test-llm') ||
      (github.event_name == 'pull_request' && github.event.label.name == 'test-llm') ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '/test-llm'))
      
    steps:
      - name: Extract custom prompt from comment
        if: github.event_name == 'issue_comment'
        id: extract_prompt
        run: |
          comment="${{ github.event.comment.body }}"
          if [[ "$comment" =~ /test-llm[[:space:]]+(.+) ]]; then
            echo "custom_prompt=${BASH_REMATCH[1]}" >> $GITHUB_OUTPUT
          else
            echo "custom_prompt=Hello, AI. Please call the complete function." >> $GITHUB_OUTPUT
          fi
          
      - name: Determine branch to checkout
        id: branch
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "branch=${{ github.event.pull_request.head.ref }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "issue_comment" && "${{ github.event.issue.pull_request }}" != "" ]]; then
            echo "branch=refs/pull/${{ github.event.issue.number }}/head" >> $GITHUB_OUTPUT
          elif [[ "${{ inputs.branch }}" != "" ]]; then
            echo "branch=${{ inputs.branch }}" >> $GITHUB_OUTPUT
          else
            echo "branch=${{ github.ref }}" >> $GITHUB_OUTPUT
          fi
          
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.branch.outputs.branch }}
          
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          
      - name: Get dependencies
        run: go mod download
          
      - name: Build makasero
        run: |
          cd cmd/makasero
          go build -v -o $GITHUB_WORKSPACE/makasero_binary
          cd -
          
      - name: Test basic LLM interaction
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          if [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            TEST_PROMPT="${{ steps.extract_prompt.outputs.custom_prompt }}"
          elif [[ "${{ inputs.test_prompt }}" != "" ]]; then
            TEST_PROMPT="${{ inputs.test_prompt }}"
          else
            TEST_PROMPT="Hello, AI. Please call the complete function."
          fi
          
          echo "Testing with prompt: $TEST_PROMPT"
          
          echo "=== Test 1: Basic Interaction ==="
          timeout 60s $GITHUB_WORKSPACE/makasero_binary -config test-config.json "$TEST_PROMPT" || echo "Test 1 completed"
          
          echo "=== Test 2: Function Calling ==="
          timeout 60s $GITHUB_WORKSPACE/makasero_binary -config test-config.json "Please call the complete function with status 'success' and message 'Function calling works!'" || echo "Test 2 completed"
          
          echo "=== Test 3: Session Persistence ==="
          timeout 60s $GITHUB_WORKSPACE/makasero_binary -config test-config.json -s test_session "Create a new session and save it." || echo "Test 3 completed"
          
          echo "All LLM integration tests completed successfully!"
          
      - name: Format session history for comment
        id: format_session
        run: |
          if [ -f ".makasero/sessions/test_session.json" ]; then
            echo "SESSION_EXISTS=true" >> $GITHUB_OUTPUT
            
            cat > format_session.go << 'EOF'
          package main
          
          import (
            "encoding/json"
            "fmt"
            "os"
            "strings"
          )
          
          type SerializablePart struct {
            Type    string      `json:"type"`
            Content interface{} `json:"content"`
          }
          
          type SerializableContent struct {
            Parts []SerializablePart `json:"parts"`
            Role  string             `json:"role"`
          }
          
          type Session struct {
            ID                string                 `json:"id"`
            SerializedHistory []SerializableContent  `json:"history"`
          }
          
          func main() {
            data, err := os.ReadFile(".makasero/sessions/test_session.json")
            if err != nil {
              fmt.Printf("Error reading session file: %v\n", err)
              return
            }
            
            var session Session
            if err := json.Unmarshal(data, &session); err != nil {
              fmt.Printf("Error parsing session JSON: %v\n", err)
              return
            }
            
            fmt.Println("## ü§ñ LLM Chat Interactions")
            fmt.Println("")
            
            for i, content := range session.SerializedHistory {
              fmt.Printf("### Message %d (%s)\n", i+1, content.Role)
              
              for _, part := range content.Parts {
                switch part.Type {
                case "text":
                  fmt.Printf("```\n%s\n```\n", part.Content)
                case "function_call":
                  if fc, ok := part.Content.(map[string]interface{}); ok {
                    fmt.Printf("**Function Call:** `%s`\n", fc["Name"])
                    if args, ok := fc["Args"].(map[string]interface{}); ok && len(args) > 0 {
                      fmt.Printf("**Arguments:** `%v`\n", args)
                    }
                  }
                case "function_response":
                  if fr, ok := part.Content.(map[string]interface{}); ok {
                    fmt.Printf("**Function Response:** `%s`\n", fr["Name"])
                    if resp, ok := fr["Response"].(map[string]interface{}); ok {
                      if output, ok := resp["output"].(string); ok && output != "" {
                        fmt.Printf("```\n%s\n```\n", output)
                      }
                    }
                  }
                }
              }
              fmt.Println("")
            }
          }
          EOF
            
            go run format_session.go > session_output.md
            
            {
              echo 'SESSION_CONTENT<<EOF'
              cat session_output.md
              echo 'EOF'
            } >> $GITHUB_OUTPUT
          else
            echo "SESSION_EXISTS=false" >> $GITHUB_OUTPUT
            echo 'SESSION_CONTENT=No session file found.' >> $GITHUB_OUTPUT
          fi
          
      - name: Comment test results on issue/PR
        if: github.event_name != 'workflow_dispatch'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.issue?.number || context.payload.pull_request?.number;
            if (issueNumber) {
              const sessionExists = '${{ steps.format_session.outputs.SESSION_EXISTS }}' === 'true';
              const sessionContent = `${{ steps.format_session.outputs.SESSION_CONTENT }}`;
              
              let body = `‚úÖ LLM Integration Test Completed
              
              **Branch**: \`${{ steps.branch.outputs.branch }}\`
              **Commit**: \`${{ github.sha }}\`
              **Tests**: Basic interaction, Function calling, Session persistence
              
              All tests completed successfully! ‚ú®`;
              
              if (sessionExists) {
                body += `\n\n${sessionContent}`;
              } else {
                body += '\n\n‚ö†Ô∏è Session history not available.';
              }
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: body
              });
            }
